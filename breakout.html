<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <title>Breakout</title>
    <style>
      * {
        padding: 0;
        margin: 0;
      }
      canvas {
        /*TODO: this background color should be set by the user 
        through JS secondo me*/
        background: #eee;
        display: block;
        margin: 0 auto;
      }
    </style>
  </head>
  <body>
    <canvas id="myCanvas" width="480" height="320"></canvas>

    <script src="collisiontest.js"></script>
    <script src="mecha.js"></script>
    <script>
// TODO: need full control over canvas creations. there has to be
// some DOM generation code in the engine that completely clears
// the stage for me
var game = new Game("myCanvas");

var score = 0;
var lives = 3;

var scoreCounter = game.createEntity();
scoreCounter.add(new Transform(55, 28));
scoreCounter.add(new TextDisplay("black", "16px Arial", "Score: " + score));

var livesCounter = game.createEntity();
livesCounter.add(new Transform(game.width - 53, 28));
livesCounter.add(new TextDisplay("black", "16px Arial", "Lives: " + lives));

// TODO: these three functions together with the three variables on top
// define a sort of game state and so should be encapsulated in a system
// that allows switching easily between game states
function endGame(outcome) {
    ball.get("transform").vx = 0;
    ball.get("transform").vy = 0;
    ball.remove("ballcontroller");
    paddle.get("transform").vx = 0;
    paddle.get("transform").vy = 0;
    paddle.remove("paddlecontroller");

    outcomeDisplay = game.createEntity();
    outcomeDisplay.add(new Transform(game.width/2, game.height/2));
    outcomeDisplay.add(new TextDisplay("red", "48px Arial", "You lose..."));
    if (outcome > 0) {
        outcomeDisplay.get("textdisplay").color = "green";
        outcomeDisplay.get("textdisplay").text = "You win!";
    }
}

function hitBrick(brick) {
    game.destroyEntity(brick);
    score++;
    scoreCounter.get("textdisplay").text = "Score: " + score;

    if (score == brickRows * brickCols) {
        endGame(1);
    }
}

function hitZone() {
    lives--;
    livesCounter.get("textdisplay").text = "Lives: " + lives;
    if (lives == 0) {
        endGame(-1);
    } else {
        var r = ball.get("ballgeometry").radius - 1;
        var v = Math.abs(ball.get("transform").vx) + 0.7;
        game.destroyEntity(ball);

        ball = game.createEntity();
        ball.add(new Transform(game.width / 2, game.height - 30));
        ball.add(new BallGeometry(r, "#FF351D"));
        ball.add(new BallController(v,-v,[wallLeft,wallRight],[wallTop,paddle].concat(bricks)));
        ball.init();
    }
}

var wallLeft = game.createEntity();
wallLeft.add(new Transform(0, game.height / 2));
wallLeft.add(new BoxGeometry(5, game.height / 2, "#9595DD"));
var wallRight = game.createEntity();
wallRight.add(new Transform(game.width, game.height / 2));
wallRight.add(new BoxGeometry(5, game.height / 2, "#9595DD"));
var wallTop = game.createEntity();
wallTop.add(new Transform(game.width / 2, 0));
wallTop.add(new BoxGeometry((game.width - 10)/2, 5, "#9595DD"));

game.registerKey("ArrowRight");
game.registerKey("ArrowLeft");
var paddle = game.createEntity();
paddle.add(new Transform(game.width / 2, game.height - 5));
paddle.add(new BoxGeometry(37.5, 5, "#0095DD"));
class PaddleController extends Component {
    constructor(speed, dontpass) {
        super("paddlecontroller");
        this.speed = speed;
        this.dontpass = dontpass;
    }
    logic() {
        var transform = this.entity.get("transform");
        var collider = this.entity.get("boxgeometry").collider;
        var aabox = new AABox(collider.center, collider.halfW, collider.halfH);

        var left = game.keyState["ArrowLeft"] ? -1 : 0;
        var right = game.keyState["ArrowRight"] ? 1 : 0;
        transform.vx = this.speed * (left + right);

        var v = new Vector(transform.vx, transform.vy);

        this.dontpass.forEach(e => {
            var c = e.get("boxgeometry").collider;
            var otherAABox = new AABox(c.center, c.halfW, c.halfH);
            var hit = aabox.sweepIntoAABox(v, otherAABox);
            if (hit.hit && hit.time <= 1) {
                v.x *= (hit.time - 1e-8);
            }
        });

        transform.vx = v.x; transform.vy = v.y;
    }
}
paddle.add(new PaddleController(7, [wallLeft,wallRight]));

var bricks = [];
var brickRows = 3;
var brickCols = 5;
for(var i = 0; i < brickRows; i++) {
    for(var j = 0; j < brickCols; j++) {
        var brick = game.createEntity("brick"); 
        brick.add(new Transform(j*85 + 70, i*30 + 50));
        brick.add(new BoxGeometry(37.5, 10, "#CC9532"));
        bricks.push(brick);
    }
}

var ball = game.createEntity();
ball.add(new Transform(game.width / 2, game.height - 30));
ball.add(new BallGeometry(10, "#FF351D"));
class BallController extends Component {
    constructor(vx, vy, verticals, horizontals) {
        super("ballcontroller");
        this.vx = vx;
        this.vy = vy;
        this.verticals = verticals;
        this.horizontals = horizontals;
    }
    init() {
        this.entity.get("transform").vx = this.vx;
        this.entity.get("transform").vy = this.vy;
    }
    logic() {
        var transform = this.entity.get("transform");
        var geom = this.entity.get("ballgeometry").collider;
        
        var v = new Vector(transform.vx, transform.vy);

        // TODO: sometimes the collision with the paddle is buggy.
        // this and the fact that the bricks dont have vertical AND
        // horizontal colliders can be fixed once and for all if 
        // I had better sweep collision code that knows the normal

        // TODO: moreover it would be nice to have a sort of spin
        // effect when you move faster or slower with the paddle
        // in the same or in the opposite direction
        this.horizontals.forEach(e => {
            if (!e.has("boxgeometry")) return;
            var hit = geom.sweepIntoBoxHull(v, e.get("boxgeometry").collider);
            if (hit.hit && hit.time <= 1) {
                v.y *= -1;
                if (e.type === "brick"){
                    hitBrick(e);
                }
            }
        });
        this.verticals.forEach(e => {
            var hit = geom.sweepIntoBoxHull(v, e.get("boxgeometry").collider);
            if (hit.hit && hit.time <= 1) {
                v.x *= -1;
            }
        });

        transform.vx = v.x; transform.vy = v.y;

        if (geom.center.y + geom.radius + transform.vy > game.height) {
            hitZone();
        }
    }
}
ball.add(new BallController(3,-3,[wallLeft,wallRight],[wallTop,paddle].concat(bricks)));
// TODO: I dont like the excessive passing of arguments here. a simple
// "find all by tag" should solve that easily

game.run();
    </script>
  </body>
</html>